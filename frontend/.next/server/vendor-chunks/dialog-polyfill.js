/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/dialog-polyfill";
exports.ids = ["vendor-chunks/dialog-polyfill"];
exports.modules = {

/***/ "(ssr)/./node_modules/dialog-polyfill/dialog-polyfill.js":
/*!*********************************************************!*\
  !*** ./node_modules/dialog-polyfill/dialog-polyfill.js ***!
  \*********************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;(function() {\n    // nb. This is for IE10 and lower _only_.\n    var supportCustomEvent = window.CustomEvent;\n    if (!supportCustomEvent || typeof supportCustomEvent === \"object\") {\n        supportCustomEvent = function CustomEvent(event, x) {\n            x = x || {};\n            var ev = document.createEvent(\"CustomEvent\");\n            ev.initCustomEvent(event, !!x.bubbles, !!x.cancelable, x.detail || null);\n            return ev;\n        };\n        supportCustomEvent.prototype = window.Event.prototype;\n    }\n    /**\n   * @param {Element} el to check for stacking context\n   * @return {boolean} whether this el or its parents creates a stacking context\n   */ function createsStackingContext(el) {\n        while(el && el !== document.body){\n            var s = window.getComputedStyle(el);\n            var invalid = function(k, ok) {\n                return !(s[k] === undefined || s[k] === ok);\n            };\n            if (s.opacity < 1 || invalid(\"zIndex\", \"auto\") || invalid(\"transform\", \"none\") || invalid(\"mixBlendMode\", \"normal\") || invalid(\"filter\", \"none\") || invalid(\"perspective\", \"none\") || s[\"isolation\"] === \"isolate\" || s.position === \"fixed\" || s.webkitOverflowScrolling === \"touch\") {\n                return true;\n            }\n            el = el.parentElement;\n        }\n        return false;\n    }\n    /**\n   * Finds the nearest <dialog> from the passed element.\n   *\n   * @param {Element} el to search from\n   * @return {HTMLDialogElement} dialog found\n   */ function findNearestDialog(el) {\n        while(el){\n            if (el.localName === \"dialog\") {\n                return /** @type {HTMLDialogElement} */ el;\n            }\n            el = el.parentElement;\n        }\n        return null;\n    }\n    /**\n   * Blur the specified element, as long as it's not the HTML body element.\n   * This works around an IE9/10 bug - blurring the body causes Windows to\n   * blur the whole application.\n   *\n   * @param {Element} el to blur\n   */ function safeBlur(el) {\n        if (el && el.blur && el !== document.body) {\n            el.blur();\n        }\n    }\n    /**\n   * @param {!NodeList} nodeList to search\n   * @param {Node} node to find\n   * @return {boolean} whether node is inside nodeList\n   */ function inNodeList(nodeList, node) {\n        for(var i = 0; i < nodeList.length; ++i){\n            if (nodeList[i] === node) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n   * @param {HTMLFormElement} el to check\n   * @return {boolean} whether this form has method=\"dialog\"\n   */ function isFormMethodDialog(el) {\n        if (!el || !el.hasAttribute(\"method\")) {\n            return false;\n        }\n        return el.getAttribute(\"method\").toLowerCase() === \"dialog\";\n    }\n    /**\n   * @param {!HTMLDialogElement} dialog to upgrade\n   * @constructor\n   */ function dialogPolyfillInfo(dialog) {\n        this.dialog_ = dialog;\n        this.replacedStyleTop_ = false;\n        this.openAsModal_ = false;\n        // Set a11y role. Browsers that support dialog implicitly know this already.\n        if (!dialog.hasAttribute(\"role\")) {\n            dialog.setAttribute(\"role\", \"dialog\");\n        }\n        dialog.show = this.show.bind(this);\n        dialog.showModal = this.showModal.bind(this);\n        dialog.close = this.close.bind(this);\n        if (!(\"returnValue\" in dialog)) {\n            dialog.returnValue = \"\";\n        }\n        if (\"MutationObserver\" in window) {\n            var mo = new MutationObserver(this.maybeHideModal.bind(this));\n            mo.observe(dialog, {\n                attributes: true,\n                attributeFilter: [\n                    \"open\"\n                ]\n            });\n        } else {\n            // IE10 and below support. Note that DOMNodeRemoved etc fire _before_ removal. They also\n            // seem to fire even if the element was removed as part of a parent removal. Use the removed\n            // events to force downgrade (useful if removed/immediately added).\n            var removed = false;\n            var cb = (function() {\n                removed ? this.downgradeModal() : this.maybeHideModal();\n                removed = false;\n            }).bind(this);\n            var timeout;\n            var delayModel = function(ev) {\n                if (ev.target !== dialog) {\n                    return;\n                } // not for a child element\n                var cand = \"DOMNodeRemoved\";\n                removed |= ev.type.substr(0, cand.length) === cand;\n                window.clearTimeout(timeout);\n                timeout = window.setTimeout(cb, 0);\n            };\n            [\n                \"DOMAttrModified\",\n                \"DOMNodeRemoved\",\n                \"DOMNodeRemovedFromDocument\"\n            ].forEach(function(name) {\n                dialog.addEventListener(name, delayModel);\n            });\n        }\n        // Note that the DOM is observed inside DialogManager while any dialog\n        // is being displayed as a modal, to catch modal removal from the DOM.\n        Object.defineProperty(dialog, \"open\", {\n            set: this.setOpen.bind(this),\n            get: dialog.hasAttribute.bind(dialog, \"open\")\n        });\n        this.backdrop_ = document.createElement(\"div\");\n        this.backdrop_.className = \"backdrop\";\n        this.backdrop_.addEventListener(\"click\", this.backdropClick_.bind(this));\n    }\n    dialogPolyfillInfo.prototype = {\n        get dialog () {\n            return this.dialog_;\n        },\n        /**\n     * Maybe remove this dialog from the modal top layer. This is called when\n     * a modal dialog may no longer be tenable, e.g., when the dialog is no\n     * longer open or is no longer part of the DOM.\n     */ maybeHideModal: function() {\n            if (this.dialog_.hasAttribute(\"open\") && document.body.contains(this.dialog_)) {\n                return;\n            }\n            this.downgradeModal();\n        },\n        /**\n     * Remove this dialog from the modal top layer, leaving it as a non-modal.\n     */ downgradeModal: function() {\n            if (!this.openAsModal_) {\n                return;\n            }\n            this.openAsModal_ = false;\n            this.dialog_.style.zIndex = \"\";\n            // This won't match the native <dialog> exactly because if the user set top on a centered\n            // polyfill dialog, that top gets thrown away when the dialog is closed. Not sure it's\n            // possible to polyfill this perfectly.\n            if (this.replacedStyleTop_) {\n                this.dialog_.style.top = \"\";\n                this.replacedStyleTop_ = false;\n            }\n            // Clear the backdrop and remove from the manager.\n            this.backdrop_.parentNode && this.backdrop_.parentNode.removeChild(this.backdrop_);\n            dialogPolyfill.dm.removeDialog(this);\n        },\n        /**\n     * @param {boolean} value whether to open or close this dialog\n     */ setOpen: function(value) {\n            if (value) {\n                this.dialog_.hasAttribute(\"open\") || this.dialog_.setAttribute(\"open\", \"\");\n            } else {\n                this.dialog_.removeAttribute(\"open\");\n                this.maybeHideModal(); // nb. redundant with MutationObserver\n            }\n        },\n        /**\n     * Handles clicks on the fake .backdrop element, redirecting them as if\n     * they were on the dialog itself.\n     *\n     * @param {!Event} e to redirect\n     */ backdropClick_: function(e) {\n            if (!this.dialog_.hasAttribute(\"tabindex\")) {\n                // Clicking on the backdrop should move the implicit cursor, even if dialog cannot be\n                // focused. Create a fake thing to focus on. If the backdrop was _before_ the dialog, this\n                // would not be needed - clicks would move the implicit cursor there.\n                var fake = document.createElement(\"div\");\n                this.dialog_.insertBefore(fake, this.dialog_.firstChild);\n                fake.tabIndex = -1;\n                fake.focus();\n                this.dialog_.removeChild(fake);\n            } else {\n                this.dialog_.focus();\n            }\n            var redirectedEvent = document.createEvent(\"MouseEvents\");\n            redirectedEvent.initMouseEvent(e.type, e.bubbles, e.cancelable, window, e.detail, e.screenX, e.screenY, e.clientX, e.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, e.button, e.relatedTarget);\n            this.dialog_.dispatchEvent(redirectedEvent);\n            e.stopPropagation();\n        },\n        /**\n     * Focuses on the first focusable element within the dialog. This will always blur the current\n     * focus, even if nothing within the dialog is found.\n     */ focus_: function() {\n            // Find element with `autofocus` attribute, or fall back to the first form/tabindex control.\n            var target = this.dialog_.querySelector(\"[autofocus]:not([disabled])\");\n            if (!target && this.dialog_.tabIndex >= 0) {\n                target = this.dialog_;\n            }\n            if (!target) {\n                // Note that this is 'any focusable area'. This list is probably not exhaustive, but the\n                // alternative involves stepping through and trying to focus everything.\n                var opts = [\n                    \"button\",\n                    \"input\",\n                    \"keygen\",\n                    \"select\",\n                    \"textarea\"\n                ];\n                var query = opts.map(function(el) {\n                    return el + \":not([disabled])\";\n                });\n                // TODO(samthor): tabindex values that are not numeric are not focusable.\n                query.push('[tabindex]:not([disabled]):not([tabindex=\"\"])'); // tabindex != \"\", not disabled\n                target = this.dialog_.querySelector(query.join(\", \"));\n            }\n            safeBlur(document.activeElement);\n            target && target.focus();\n        },\n        /**\n     * Sets the zIndex for the backdrop and dialog.\n     *\n     * @param {number} dialogZ\n     * @param {number} backdropZ\n     */ updateZIndex: function(dialogZ, backdropZ) {\n            if (dialogZ < backdropZ) {\n                throw new Error(\"dialogZ should never be < backdropZ\");\n            }\n            this.dialog_.style.zIndex = dialogZ;\n            this.backdrop_.style.zIndex = backdropZ;\n        },\n        /**\n     * Shows the dialog. If the dialog is already open, this does nothing.\n     */ show: function() {\n            if (!this.dialog_.open) {\n                this.setOpen(true);\n                this.focus_();\n            }\n        },\n        /**\n     * Show this dialog modally.\n     */ showModal: function() {\n            if (this.dialog_.hasAttribute(\"open\")) {\n                throw new Error(\"Failed to execute 'showModal' on dialog: The element is already open, and therefore cannot be opened modally.\");\n            }\n            if (!document.body.contains(this.dialog_)) {\n                throw new Error(\"Failed to execute 'showModal' on dialog: The element is not in a Document.\");\n            }\n            if (!dialogPolyfill.dm.pushDialog(this)) {\n                throw new Error(\"Failed to execute 'showModal' on dialog: There are too many open modal dialogs.\");\n            }\n            if (createsStackingContext(this.dialog_.parentElement)) {\n                console.warn(\"A dialog is being shown inside a stacking context. \" + \"This may cause it to be unusable. For more information, see this link: \" + \"https://github.com/GoogleChrome/dialog-polyfill/#stacking-context\");\n            }\n            this.setOpen(true);\n            this.openAsModal_ = true;\n            // Optionally center vertically, relative to the current viewport.\n            if (dialogPolyfill.needsCentering(this.dialog_)) {\n                dialogPolyfill.reposition(this.dialog_);\n                this.replacedStyleTop_ = true;\n            } else {\n                this.replacedStyleTop_ = false;\n            }\n            // Insert backdrop.\n            this.dialog_.parentNode.insertBefore(this.backdrop_, this.dialog_.nextSibling);\n            // Focus on whatever inside the dialog.\n            this.focus_();\n        },\n        /**\n     * Closes this HTMLDialogElement. This is optional vs clearing the open\n     * attribute, however this fires a 'close' event.\n     *\n     * @param {string=} opt_returnValue to use as the returnValue\n     */ close: function(opt_returnValue) {\n            if (!this.dialog_.hasAttribute(\"open\")) {\n                throw new Error(\"Failed to execute 'close' on dialog: The element does not have an 'open' attribute, and therefore cannot be closed.\");\n            }\n            this.setOpen(false);\n            // Leave returnValue untouched in case it was set directly on the element\n            if (opt_returnValue !== undefined) {\n                this.dialog_.returnValue = opt_returnValue;\n            }\n            // Triggering \"close\" event for any attached listeners on the <dialog>.\n            var closeEvent = new supportCustomEvent(\"close\", {\n                bubbles: false,\n                cancelable: false\n            });\n            this.dialog_.dispatchEvent(closeEvent);\n        }\n    };\n    var dialogPolyfill = {};\n    dialogPolyfill.reposition = function(element) {\n        var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n        var topValue = scrollTop + (window.innerHeight - element.offsetHeight) / 2;\n        element.style.top = Math.max(scrollTop, topValue) + \"px\";\n    };\n    dialogPolyfill.isInlinePositionSetByStylesheet = function(element) {\n        for(var i = 0; i < document.styleSheets.length; ++i){\n            var styleSheet = document.styleSheets[i];\n            var cssRules = null;\n            // Some browsers throw on cssRules.\n            try {\n                cssRules = styleSheet.cssRules;\n            } catch (e) {}\n            if (!cssRules) {\n                continue;\n            }\n            for(var j = 0; j < cssRules.length; ++j){\n                var rule = cssRules[j];\n                var selectedNodes = null;\n                // Ignore errors on invalid selector texts.\n                try {\n                    selectedNodes = document.querySelectorAll(rule.selectorText);\n                } catch (e) {}\n                if (!selectedNodes || !inNodeList(selectedNodes, element)) {\n                    continue;\n                }\n                var cssTop = rule.style.getPropertyValue(\"top\");\n                var cssBottom = rule.style.getPropertyValue(\"bottom\");\n                if (cssTop && cssTop !== \"auto\" || cssBottom && cssBottom !== \"auto\") {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n    dialogPolyfill.needsCentering = function(dialog) {\n        var computedStyle = window.getComputedStyle(dialog);\n        if (computedStyle.position !== \"absolute\") {\n            return false;\n        }\n        // We must determine whether the top/bottom specified value is non-auto.  In\n        // WebKit/Blink, checking computedStyle.top == 'auto' is sufficient, but\n        // Firefox returns the used value. So we do this crazy thing instead: check\n        // the inline style and then go through CSS rules.\n        if (dialog.style.top !== \"auto\" && dialog.style.top !== \"\" || dialog.style.bottom !== \"auto\" && dialog.style.bottom !== \"\") {\n            return false;\n        }\n        return !dialogPolyfill.isInlinePositionSetByStylesheet(dialog);\n    };\n    /**\n   * @param {!Element} element to force upgrade\n   */ dialogPolyfill.forceRegisterDialog = function(element) {\n        if (window.HTMLDialogElement || element.showModal) {\n            console.warn(\"This browser already supports <dialog>, the polyfill \" + \"may not work correctly\", element);\n        }\n        if (element.localName !== \"dialog\") {\n            throw new Error(\"Failed to register dialog: The element is not a dialog.\");\n        }\n        new dialogPolyfillInfo(/** @type {!HTMLDialogElement} */ element);\n    };\n    /**\n   * @param {!Element} element to upgrade, if necessary\n   */ dialogPolyfill.registerDialog = function(element) {\n        if (!element.showModal) {\n            dialogPolyfill.forceRegisterDialog(element);\n        }\n    };\n    /**\n   * @constructor\n   */ dialogPolyfill.DialogManager = function() {\n        /** @type {!Array<!dialogPolyfillInfo>} */ this.pendingDialogStack = [];\n        var checkDOM = this.checkDOM_.bind(this);\n        // The overlay is used to simulate how a modal dialog blocks the document.\n        // The blocking dialog is positioned on top of the overlay, and the rest of\n        // the dialogs on the pending dialog stack are positioned below it. In the\n        // actual implementation, the modal dialog stacking is controlled by the\n        // top layer, where z-index has no effect.\n        this.overlay = document.createElement(\"div\");\n        this.overlay.className = \"_dialog_overlay\";\n        this.overlay.addEventListener(\"click\", (function(e) {\n            this.forwardTab_ = undefined;\n            e.stopPropagation();\n            checkDOM([]); // sanity-check DOM\n        }).bind(this));\n        this.handleKey_ = this.handleKey_.bind(this);\n        this.handleFocus_ = this.handleFocus_.bind(this);\n        this.zIndexLow_ = 100000;\n        this.zIndexHigh_ = 100000 + 150;\n        this.forwardTab_ = undefined;\n        if (\"MutationObserver\" in window) {\n            this.mo_ = new MutationObserver(function(records) {\n                var removed = [];\n                records.forEach(function(rec) {\n                    for(var i = 0, c; c = rec.removedNodes[i]; ++i){\n                        if (!(c instanceof Element)) {\n                            continue;\n                        } else if (c.localName === \"dialog\") {\n                            removed.push(c);\n                        }\n                        removed = removed.concat(c.querySelectorAll(\"dialog\"));\n                    }\n                });\n                removed.length && checkDOM(removed);\n            });\n        }\n    };\n    /**\n   * Called on the first modal dialog being shown. Adds the overlay and related\n   * handlers.\n   */ dialogPolyfill.DialogManager.prototype.blockDocument = function() {\n        document.documentElement.addEventListener(\"focus\", this.handleFocus_, true);\n        document.addEventListener(\"keydown\", this.handleKey_);\n        this.mo_ && this.mo_.observe(document, {\n            childList: true,\n            subtree: true\n        });\n    };\n    /**\n   * Called on the first modal dialog being removed, i.e., when no more modal\n   * dialogs are visible.\n   */ dialogPolyfill.DialogManager.prototype.unblockDocument = function() {\n        document.documentElement.removeEventListener(\"focus\", this.handleFocus_, true);\n        document.removeEventListener(\"keydown\", this.handleKey_);\n        this.mo_ && this.mo_.disconnect();\n    };\n    /**\n   * Updates the stacking of all known dialogs.\n   */ dialogPolyfill.DialogManager.prototype.updateStacking = function() {\n        var zIndex = this.zIndexHigh_;\n        for(var i = 0, dpi; dpi = this.pendingDialogStack[i]; ++i){\n            dpi.updateZIndex(--zIndex, --zIndex);\n            if (i === 0) {\n                this.overlay.style.zIndex = --zIndex;\n            }\n        }\n        // Make the overlay a sibling of the dialog itself.\n        var last = this.pendingDialogStack[0];\n        if (last) {\n            var p = last.dialog.parentNode || document.body;\n            p.appendChild(this.overlay);\n        } else if (this.overlay.parentNode) {\n            this.overlay.parentNode.removeChild(this.overlay);\n        }\n    };\n    /**\n   * @param {Element} candidate to check if contained or is the top-most modal dialog\n   * @return {boolean} whether candidate is contained in top dialog\n   */ dialogPolyfill.DialogManager.prototype.containedByTopDialog_ = function(candidate) {\n        while(candidate = findNearestDialog(candidate)){\n            for(var i = 0, dpi; dpi = this.pendingDialogStack[i]; ++i){\n                if (dpi.dialog === candidate) {\n                    return i === 0; // only valid if top-most\n                }\n            }\n            candidate = candidate.parentElement;\n        }\n        return false;\n    };\n    dialogPolyfill.DialogManager.prototype.handleFocus_ = function(event) {\n        if (this.containedByTopDialog_(event.target)) {\n            return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n        safeBlur(/** @type {Element} */ event.target);\n        if (this.forwardTab_ === undefined) {\n            return;\n        } // move focus only from a tab key\n        var dpi = this.pendingDialogStack[0];\n        var dialog = dpi.dialog;\n        var position = dialog.compareDocumentPosition(event.target);\n        if (position & Node.DOCUMENT_POSITION_PRECEDING) {\n            if (this.forwardTab_) {\n                dpi.focus_();\n            } else {\n                document.documentElement.focus();\n            }\n        } else {\n        // TODO: Focus after the dialog, is ignored.\n        }\n        return false;\n    };\n    dialogPolyfill.DialogManager.prototype.handleKey_ = function(event) {\n        this.forwardTab_ = undefined;\n        if (event.keyCode === 27) {\n            event.preventDefault();\n            event.stopPropagation();\n            var cancelEvent = new supportCustomEvent(\"cancel\", {\n                bubbles: false,\n                cancelable: true\n            });\n            var dpi = this.pendingDialogStack[0];\n            if (dpi && dpi.dialog.dispatchEvent(cancelEvent)) {\n                dpi.dialog.close();\n            }\n        } else if (event.keyCode === 9) {\n            this.forwardTab_ = !event.shiftKey;\n        }\n    };\n    /**\n   * Finds and downgrades any known modal dialogs that are no longer displayed. Dialogs that are\n   * removed and immediately readded don't stay modal, they become normal.\n   *\n   * @param {!Array<!HTMLDialogElement>} removed that have definitely been removed\n   */ dialogPolyfill.DialogManager.prototype.checkDOM_ = function(removed) {\n        // This operates on a clone because it may cause it to change. Each change also calls\n        // updateStacking, which only actually needs to happen once. But who removes many modal dialogs\n        // at a time?!\n        var clone = this.pendingDialogStack.slice();\n        clone.forEach(function(dpi) {\n            if (removed.indexOf(dpi.dialog) !== -1) {\n                dpi.downgradeModal();\n            } else {\n                dpi.maybeHideModal();\n            }\n        });\n    };\n    /**\n   * @param {!dialogPolyfillInfo} dpi\n   * @return {boolean} whether the dialog was allowed\n   */ dialogPolyfill.DialogManager.prototype.pushDialog = function(dpi) {\n        var allowed = (this.zIndexHigh_ - this.zIndexLow_) / 2 - 1;\n        if (this.pendingDialogStack.length >= allowed) {\n            return false;\n        }\n        if (this.pendingDialogStack.unshift(dpi) === 1) {\n            this.blockDocument();\n        }\n        this.updateStacking();\n        return true;\n    };\n    /**\n   * @param {!dialogPolyfillInfo} dpi\n   */ dialogPolyfill.DialogManager.prototype.removeDialog = function(dpi) {\n        var index = this.pendingDialogStack.indexOf(dpi);\n        if (index === -1) {\n            return;\n        }\n        this.pendingDialogStack.splice(index, 1);\n        if (this.pendingDialogStack.length === 0) {\n            this.unblockDocument();\n        }\n        this.updateStacking();\n    };\n    dialogPolyfill.dm = new dialogPolyfill.DialogManager();\n    dialogPolyfill.formSubmitter = null;\n    dialogPolyfill.useValue = null;\n    /**\n   * Installs global handlers, such as click listers and native method overrides. These are needed\n   * even if a no dialog is registered, as they deal with <form method=\"dialog\">.\n   */ if (window.HTMLDialogElement === undefined) {\n        /**\n     * If HTMLFormElement translates method=\"DIALOG\" into 'get', then replace the descriptor with\n     * one that returns the correct value.\n     */ var testForm = document.createElement(\"form\");\n        testForm.setAttribute(\"method\", \"dialog\");\n        if (testForm.method !== \"dialog\") {\n            var methodDescriptor = Object.getOwnPropertyDescriptor(HTMLFormElement.prototype, \"method\");\n            if (methodDescriptor) {\n                // nb. Some older iOS and older PhantomJS fail to return the descriptor. Don't do anything\n                // and don't bother to update the element.\n                var realGet = methodDescriptor.get;\n                methodDescriptor.get = function() {\n                    if (isFormMethodDialog(this)) {\n                        return \"dialog\";\n                    }\n                    return realGet.call(this);\n                };\n                var realSet = methodDescriptor.set;\n                methodDescriptor.set = function(v) {\n                    if (typeof v === \"string\" && v.toLowerCase() === \"dialog\") {\n                        return this.setAttribute(\"method\", v);\n                    }\n                    return realSet.call(this, v);\n                };\n                Object.defineProperty(HTMLFormElement.prototype, \"method\", methodDescriptor);\n            }\n        }\n        /**\n     * Global 'click' handler, to capture the <input type=\"submit\"> or <button> element which has\n     * submitted a <form method=\"dialog\">. Needed as Safari and others don't report this inside\n     * document.activeElement.\n     */ document.addEventListener(\"click\", function(ev) {\n            dialogPolyfill.formSubmitter = null;\n            dialogPolyfill.useValue = null;\n            if (ev.defaultPrevented) {\n                return;\n            } // e.g. a submit which prevents default submission\n            var target = /** @type {Element} */ ev.target;\n            if (!target || !isFormMethodDialog(target.form)) {\n                return;\n            }\n            var valid = target.type === \"submit\" && [\n                \"button\",\n                \"input\"\n            ].indexOf(target.localName) > -1;\n            if (!valid) {\n                if (!(target.localName === \"input\" && target.type === \"image\")) {\n                    return;\n                }\n                // this is a <input type=\"image\">, which can submit forms\n                dialogPolyfill.useValue = ev.offsetX + \",\" + ev.offsetY;\n            }\n            var dialog = findNearestDialog(target);\n            if (!dialog) {\n                return;\n            }\n            dialogPolyfill.formSubmitter = target;\n        }, false);\n        /**\n     * Replace the native HTMLFormElement.submit() method, as it won't fire the\n     * submit event and give us a chance to respond.\n     */ var nativeFormSubmit = HTMLFormElement.prototype.submit;\n        var replacementFormSubmit = function() {\n            if (!isFormMethodDialog(this)) {\n                return nativeFormSubmit.call(this);\n            }\n            var dialog = findNearestDialog(this);\n            dialog && dialog.close();\n        };\n        HTMLFormElement.prototype.submit = replacementFormSubmit;\n        /**\n     * Global form 'dialog' method handler. Closes a dialog correctly on submit\n     * and possibly sets its return value.\n     */ document.addEventListener(\"submit\", function(ev) {\n            var form = /** @type {HTMLFormElement} */ ev.target;\n            if (!isFormMethodDialog(form)) {\n                return;\n            }\n            ev.preventDefault();\n            var dialog = findNearestDialog(form);\n            if (!dialog) {\n                return;\n            }\n            // Forms can only be submitted via .submit() or a click (?), but anyway: sanity-check that\n            // the submitter is correct before using its value as .returnValue.\n            var s = dialogPolyfill.formSubmitter;\n            if (s && s.form === form) {\n                dialog.close(dialogPolyfill.useValue || s.value);\n            } else {\n                dialog.close();\n            }\n            dialogPolyfill.formSubmitter = null;\n        }, true);\n    }\n    dialogPolyfill[\"forceRegisterDialog\"] = dialogPolyfill.forceRegisterDialog;\n    dialogPolyfill[\"registerDialog\"] = dialogPolyfill.registerDialog;\n    if ( true && \"amd\" in __webpack_require__.amdD) {\n        // AMD support\n        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n            return dialogPolyfill;\n        }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if ( true && typeof module[\"exports\"] === \"object\") {\n        // CommonJS support\n        module[\"exports\"] = dialogPolyfill;\n    } else {\n        // all others\n        window[\"dialogPolyfill\"] = dialogPolyfill;\n    }\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZGlhbG9nLXBvbHlmaWxsL2RpYWxvZy1wb2x5ZmlsbC5qcyIsIm1hcHBpbmdzIjoiQUFBQztJQUVDLHlDQUF5QztJQUN6QyxJQUFJQSxxQkFBcUJDLE9BQU9DLFdBQVc7SUFDM0MsSUFBSSxDQUFDRixzQkFBc0IsT0FBT0EsdUJBQXVCLFVBQVU7UUFDakVBLHFCQUFxQixTQUFTRSxZQUFZQyxLQUFLLEVBQUVDLENBQUM7WUFDaERBLElBQUlBLEtBQUssQ0FBQztZQUNWLElBQUlDLEtBQUtDLFNBQVNDLFdBQVcsQ0FBQztZQUM5QkYsR0FBR0csZUFBZSxDQUFDTCxPQUFPLENBQUMsQ0FBQ0MsRUFBRUssT0FBTyxFQUFFLENBQUMsQ0FBQ0wsRUFBRU0sVUFBVSxFQUFFTixFQUFFTyxNQUFNLElBQUk7WUFDbkUsT0FBT047UUFDVDtRQUNBTCxtQkFBbUJZLFNBQVMsR0FBR1gsT0FBT1ksS0FBSyxDQUFDRCxTQUFTO0lBQ3ZEO0lBRUE7OztHQUdDLEdBQ0QsU0FBU0UsdUJBQXVCQyxFQUFFO1FBQ2hDLE1BQU9BLE1BQU1BLE9BQU9ULFNBQVNVLElBQUksQ0FBRTtZQUNqQyxJQUFJQyxJQUFJaEIsT0FBT2lCLGdCQUFnQixDQUFDSDtZQUNoQyxJQUFJSSxVQUFVLFNBQVNDLENBQUMsRUFBRUMsRUFBRTtnQkFDMUIsT0FBTyxDQUFFSixDQUFBQSxDQUFDLENBQUNHLEVBQUUsS0FBS0UsYUFBYUwsQ0FBQyxDQUFDRyxFQUFFLEtBQUtDLEVBQUM7WUFDM0M7WUFDQSxJQUFJSixFQUFFTSxPQUFPLEdBQUcsS0FDWkosUUFBUSxVQUFVLFdBQ2xCQSxRQUFRLGFBQWEsV0FDckJBLFFBQVEsZ0JBQWdCLGFBQ3hCQSxRQUFRLFVBQVUsV0FDbEJBLFFBQVEsZUFBZSxXQUN2QkYsQ0FBQyxDQUFDLFlBQVksS0FBSyxhQUNuQkEsRUFBRU8sUUFBUSxLQUFLLFdBQ2ZQLEVBQUVRLHVCQUF1QixLQUFLLFNBQVM7Z0JBQ3pDLE9BQU87WUFDVDtZQUNB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akMsR0FBRztJQUNMO0lBRUFsSCxjQUFjLENBQUMsc0JBQXNCLEdBQUdBLGVBQWVvRSxtQkFBbUI7SUFDMUVwRSxjQUFjLENBQUMsaUJBQWlCLEdBQUdBLGVBQWVzRSxjQUFjO0lBRWhFLElBQUksS0FBa0IsSUFBYyxTQUFTK0Qsd0JBQU1BLEVBQUU7UUFDbkQsY0FBYztRQUNkQSxtQ0FBTztZQUFhLE9BQU9ySTtRQUFnQixDQUFDO0FBQUEsa0dBQUM7SUFDL0MsT0FBTyxJQUFJLEtBQWtCLElBQVksT0FBT3NJLE1BQU0sQ0FBQyxVQUFVLEtBQUssVUFBVTtRQUM5RSxtQkFBbUI7UUFDbkJBLE1BQU0sQ0FBQyxVQUFVLEdBQUd0STtJQUN0QixPQUFPO1FBQ0wsYUFBYTtRQUNickYsTUFBTSxDQUFDLGlCQUFpQixHQUFHcUY7SUFDN0I7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9kaWFsb2ctcG9seWZpbGwvZGlhbG9nLXBvbHlmaWxsLmpzP2MzNzAiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCkge1xuXG4gIC8vIG5iLiBUaGlzIGlzIGZvciBJRTEwIGFuZCBsb3dlciBfb25seV8uXG4gIHZhciBzdXBwb3J0Q3VzdG9tRXZlbnQgPSB3aW5kb3cuQ3VzdG9tRXZlbnQ7XG4gIGlmICghc3VwcG9ydEN1c3RvbUV2ZW50IHx8IHR5cGVvZiBzdXBwb3J0Q3VzdG9tRXZlbnQgPT09ICdvYmplY3QnKSB7XG4gICAgc3VwcG9ydEN1c3RvbUV2ZW50ID0gZnVuY3Rpb24gQ3VzdG9tRXZlbnQoZXZlbnQsIHgpIHtcbiAgICAgIHggPSB4IHx8IHt9O1xuICAgICAgdmFyIGV2ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgICBldi5pbml0Q3VzdG9tRXZlbnQoZXZlbnQsICEheC5idWJibGVzLCAhIXguY2FuY2VsYWJsZSwgeC5kZXRhaWwgfHwgbnVsbCk7XG4gICAgICByZXR1cm4gZXY7XG4gICAgfTtcbiAgICBzdXBwb3J0Q3VzdG9tRXZlbnQucHJvdG90eXBlID0gd2luZG93LkV2ZW50LnByb3RvdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsIHRvIGNoZWNrIGZvciBzdGFja2luZyBjb250ZXh0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IHdoZXRoZXIgdGhpcyBlbCBvciBpdHMgcGFyZW50cyBjcmVhdGVzIGEgc3RhY2tpbmcgY29udGV4dFxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlc1N0YWNraW5nQ29udGV4dChlbCkge1xuICAgIHdoaWxlIChlbCAmJiBlbCAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgdmFyIHMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgICB2YXIgaW52YWxpZCA9IGZ1bmN0aW9uKGssIG9rKSB7XG4gICAgICAgIHJldHVybiAhKHNba10gPT09IHVuZGVmaW5lZCB8fCBzW2tdID09PSBvayk7XG4gICAgICB9XG4gICAgICBpZiAocy5vcGFjaXR5IDwgMSB8fFxuICAgICAgICAgIGludmFsaWQoJ3pJbmRleCcsICdhdXRvJykgfHxcbiAgICAgICAgICBpbnZhbGlkKCd0cmFuc2Zvcm0nLCAnbm9uZScpIHx8XG4gICAgICAgICAgaW52YWxpZCgnbWl4QmxlbmRNb2RlJywgJ25vcm1hbCcpIHx8XG4gICAgICAgICAgaW52YWxpZCgnZmlsdGVyJywgJ25vbmUnKSB8fFxuICAgICAgICAgIGludmFsaWQoJ3BlcnNwZWN0aXZlJywgJ25vbmUnKSB8fFxuICAgICAgICAgIHNbJ2lzb2xhdGlvbiddID09PSAnaXNvbGF0ZScgfHxcbiAgICAgICAgICBzLnBvc2l0aW9uID09PSAnZml4ZWQnIHx8XG4gICAgICAgICAgcy53ZWJraXRPdmVyZmxvd1Njcm9sbGluZyA9PT0gJ3RvdWNoJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGVsID0gZWwucGFyZW50RWxlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSBuZWFyZXN0IDxkaWFsb2c+IGZyb20gdGhlIHBhc3NlZCBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsIHRvIHNlYXJjaCBmcm9tXG4gICAqIEByZXR1cm4ge0hUTUxEaWFsb2dFbGVtZW50fSBkaWFsb2cgZm91bmRcbiAgICovXG4gIGZ1bmN0aW9uIGZpbmROZWFyZXN0RGlhbG9nKGVsKSB7XG4gICAgd2hpbGUgKGVsKSB7XG4gICAgICBpZiAoZWwubG9jYWxOYW1lID09PSAnZGlhbG9nJykge1xuICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHtIVE1MRGlhbG9nRWxlbWVudH0gKi8gKGVsKTtcbiAgICAgIH1cbiAgICAgIGVsID0gZWwucGFyZW50RWxlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQmx1ciB0aGUgc3BlY2lmaWVkIGVsZW1lbnQsIGFzIGxvbmcgYXMgaXQncyBub3QgdGhlIEhUTUwgYm9keSBlbGVtZW50LlxuICAgKiBUaGlzIHdvcmtzIGFyb3VuZCBhbiBJRTkvMTAgYnVnIC0gYmx1cnJpbmcgdGhlIGJvZHkgY2F1c2VzIFdpbmRvd3MgdG9cbiAgICogYmx1ciB0aGUgd2hvbGUgYXBwbGljYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWwgdG8gYmx1clxuICAgKi9cbiAgZnVuY3Rpb24gc2FmZUJsdXIoZWwpIHtcbiAgICBpZiAoZWwgJiYgZWwuYmx1ciAmJiBlbCAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgZWwuYmx1cigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFOb2RlTGlzdH0gbm9kZUxpc3QgdG8gc2VhcmNoXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSB0byBmaW5kXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IHdoZXRoZXIgbm9kZSBpcyBpbnNpZGUgbm9kZUxpc3RcbiAgICovXG4gIGZ1bmN0aW9uIGluTm9kZUxpc3Qobm9kZUxpc3QsIG5vZGUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVMaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAobm9kZUxpc3RbaV0gPT09IG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxGb3JtRWxlbWVudH0gZWwgdG8gY2hlY2tcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gd2hldGhlciB0aGlzIGZvcm0gaGFzIG1ldGhvZD1cImRpYWxvZ1wiXG4gICAqL1xuICBmdW5jdGlvbiBpc0Zvcm1NZXRob2REaWFsb2coZWwpIHtcbiAgICBpZiAoIWVsIHx8ICFlbC5oYXNBdHRyaWJ1dGUoJ21ldGhvZCcpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoJ21ldGhvZCcpLnRvTG93ZXJDYXNlKCkgPT09ICdkaWFsb2cnO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUhUTUxEaWFsb2dFbGVtZW50fSBkaWFsb2cgdG8gdXBncmFkZVxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIGRpYWxvZ1BvbHlmaWxsSW5mbyhkaWFsb2cpIHtcbiAgICB0aGlzLmRpYWxvZ18gPSBkaWFsb2c7XG4gICAgdGhpcy5yZXBsYWNlZFN0eWxlVG9wXyA9IGZhbHNlO1xuICAgIHRoaXMub3BlbkFzTW9kYWxfID0gZmFsc2U7XG5cbiAgICAvLyBTZXQgYTExeSByb2xlLiBCcm93c2VycyB0aGF0IHN1cHBvcnQgZGlhbG9nIGltcGxpY2l0bHkga25vdyB0aGlzIGFscmVhZHkuXG4gICAgaWYgKCFkaWFsb2cuaGFzQXR0cmlidXRlKCdyb2xlJykpIHtcbiAgICAgIGRpYWxvZy5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnZGlhbG9nJyk7XG4gICAgfVxuXG4gICAgZGlhbG9nLnNob3cgPSB0aGlzLnNob3cuYmluZCh0aGlzKTtcbiAgICBkaWFsb2cuc2hvd01vZGFsID0gdGhpcy5zaG93TW9kYWwuYmluZCh0aGlzKTtcbiAgICBkaWFsb2cuY2xvc2UgPSB0aGlzLmNsb3NlLmJpbmQodGhpcyk7XG5cbiAgICBpZiAoISgncmV0dXJuVmFsdWUnIGluIGRpYWxvZykpIHtcbiAgICAgIGRpYWxvZy5yZXR1cm5WYWx1ZSA9ICcnO1xuICAgIH1cblxuICAgIGlmICgnTXV0YXRpb25PYnNlcnZlcicgaW4gd2luZG93KSB7XG4gICAgICB2YXIgbW8gPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLm1heWJlSGlkZU1vZGFsLmJpbmQodGhpcykpO1xuICAgICAgbW8ub2JzZXJ2ZShkaWFsb2csIHthdHRyaWJ1dGVzOiB0cnVlLCBhdHRyaWJ1dGVGaWx0ZXI6IFsnb3BlbiddfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElFMTAgYW5kIGJlbG93IHN1cHBvcnQuIE5vdGUgdGhhdCBET01Ob2RlUmVtb3ZlZCBldGMgZmlyZSBfYmVmb3JlXyByZW1vdmFsLiBUaGV5IGFsc29cbiAgICAgIC8vIHNlZW0gdG8gZmlyZSBldmVuIGlmIHRoZSBlbGVtZW50IHdhcyByZW1vdmVkIGFzIHBhcnQgb2YgYSBwYXJlbnQgcmVtb3ZhbC4gVXNlIHRoZSByZW1vdmVkXG4gICAgICAvLyBldmVudHMgdG8gZm9yY2UgZG93bmdyYWRlICh1c2VmdWwgaWYgcmVtb3ZlZC9pbW1lZGlhdGVseSBhZGRlZCkuXG4gICAgICB2YXIgcmVtb3ZlZCA9IGZhbHNlO1xuICAgICAgdmFyIGNiID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlbW92ZWQgPyB0aGlzLmRvd25ncmFkZU1vZGFsKCkgOiB0aGlzLm1heWJlSGlkZU1vZGFsKCk7XG4gICAgICAgIHJlbW92ZWQgPSBmYWxzZTtcbiAgICAgIH0uYmluZCh0aGlzKTtcbiAgICAgIHZhciB0aW1lb3V0O1xuICAgICAgdmFyIGRlbGF5TW9kZWwgPSBmdW5jdGlvbihldikge1xuICAgICAgICBpZiAoZXYudGFyZ2V0ICE9PSBkaWFsb2cpIHsgcmV0dXJuOyB9ICAvLyBub3QgZm9yIGEgY2hpbGQgZWxlbWVudFxuICAgICAgICB2YXIgY2FuZCA9ICdET01Ob2RlUmVtb3ZlZCc7XG4gICAgICAgIHJlbW92ZWQgfD0gKGV2LnR5cGUuc3Vic3RyKDAsIGNhbmQubGVuZ3RoKSA9PT0gY2FuZCk7XG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChjYiwgMCk7XG4gICAgICB9O1xuICAgICAgWydET01BdHRyTW9kaWZpZWQnLCAnRE9NTm9kZVJlbW92ZWQnLCAnRE9NTm9kZVJlbW92ZWRGcm9tRG9jdW1lbnQnXS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgZGlhbG9nLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZGVsYXlNb2RlbCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gTm90ZSB0aGF0IHRoZSBET00gaXMgb2JzZXJ2ZWQgaW5zaWRlIERpYWxvZ01hbmFnZXIgd2hpbGUgYW55IGRpYWxvZ1xuICAgIC8vIGlzIGJlaW5nIGRpc3BsYXllZCBhcyBhIG1vZGFsLCB0byBjYXRjaCBtb2RhbCByZW1vdmFsIGZyb20gdGhlIERPTS5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkaWFsb2csICdvcGVuJywge1xuICAgICAgc2V0OiB0aGlzLnNldE9wZW4uYmluZCh0aGlzKSxcbiAgICAgIGdldDogZGlhbG9nLmhhc0F0dHJpYnV0ZS5iaW5kKGRpYWxvZywgJ29wZW4nKVxuICAgIH0pO1xuXG4gICAgdGhpcy5iYWNrZHJvcF8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmJhY2tkcm9wXy5jbGFzc05hbWUgPSAnYmFja2Ryb3AnO1xuICAgIHRoaXMuYmFja2Ryb3BfLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5iYWNrZHJvcENsaWNrXy5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIGRpYWxvZ1BvbHlmaWxsSW5mby5wcm90b3R5cGUgPSB7XG5cbiAgICBnZXQgZGlhbG9nKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGlhbG9nXztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWF5YmUgcmVtb3ZlIHRoaXMgZGlhbG9nIGZyb20gdGhlIG1vZGFsIHRvcCBsYXllci4gVGhpcyBpcyBjYWxsZWQgd2hlblxuICAgICAqIGEgbW9kYWwgZGlhbG9nIG1heSBubyBsb25nZXIgYmUgdGVuYWJsZSwgZS5nLiwgd2hlbiB0aGUgZGlhbG9nIGlzIG5vXG4gICAgICogbG9uZ2VyIG9wZW4gb3IgaXMgbm8gbG9uZ2VyIHBhcnQgb2YgdGhlIERPTS5cbiAgICAgKi9cbiAgICBtYXliZUhpZGVNb2RhbDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5kaWFsb2dfLmhhc0F0dHJpYnV0ZSgnb3BlbicpICYmIGRvY3VtZW50LmJvZHkuY29udGFpbnModGhpcy5kaWFsb2dfKSkgeyByZXR1cm47IH1cbiAgICAgIHRoaXMuZG93bmdyYWRlTW9kYWwoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoaXMgZGlhbG9nIGZyb20gdGhlIG1vZGFsIHRvcCBsYXllciwgbGVhdmluZyBpdCBhcyBhIG5vbi1tb2RhbC5cbiAgICAgKi9cbiAgICBkb3duZ3JhZGVNb2RhbDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMub3BlbkFzTW9kYWxfKSB7IHJldHVybjsgfVxuICAgICAgdGhpcy5vcGVuQXNNb2RhbF8gPSBmYWxzZTtcbiAgICAgIHRoaXMuZGlhbG9nXy5zdHlsZS56SW5kZXggPSAnJztcblxuICAgICAgLy8gVGhpcyB3b24ndCBtYXRjaCB0aGUgbmF0aXZlIDxkaWFsb2c+IGV4YWN0bHkgYmVjYXVzZSBpZiB0aGUgdXNlciBzZXQgdG9wIG9uIGEgY2VudGVyZWRcbiAgICAgIC8vIHBvbHlmaWxsIGRpYWxvZywgdGhhdCB0b3AgZ2V0cyB0aHJvd24gYXdheSB3aGVuIHRoZSBkaWFsb2cgaXMgY2xvc2VkLiBOb3Qgc3VyZSBpdCdzXG4gICAgICAvLyBwb3NzaWJsZSB0byBwb2x5ZmlsbCB0aGlzIHBlcmZlY3RseS5cbiAgICAgIGlmICh0aGlzLnJlcGxhY2VkU3R5bGVUb3BfKSB7XG4gICAgICAgIHRoaXMuZGlhbG9nXy5zdHlsZS50b3AgPSAnJztcbiAgICAgICAgdGhpcy5yZXBsYWNlZFN0eWxlVG9wXyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBDbGVhciB0aGUgYmFja2Ryb3AgYW5kIHJlbW92ZSBmcm9tIHRoZSBtYW5hZ2VyLlxuICAgICAgdGhpcy5iYWNrZHJvcF8ucGFyZW50Tm9kZSAmJiB0aGlzLmJhY2tkcm9wXy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuYmFja2Ryb3BfKTtcbiAgICAgIGRpYWxvZ1BvbHlmaWxsLmRtLnJlbW92ZURpYWxvZyh0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtib29sZWFufSB2YWx1ZSB3aGV0aGVyIHRvIG9wZW4gb3IgY2xvc2UgdGhpcyBkaWFsb2dcbiAgICAgKi9cbiAgICBzZXRPcGVuOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGlhbG9nXy5oYXNBdHRyaWJ1dGUoJ29wZW4nKSB8fCB0aGlzLmRpYWxvZ18uc2V0QXR0cmlidXRlKCdvcGVuJywgJycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kaWFsb2dfLnJlbW92ZUF0dHJpYnV0ZSgnb3BlbicpO1xuICAgICAgICB0aGlzLm1heWJlSGlkZU1vZGFsKCk7ICAvLyBuYi4gcmVkdW5kYW50IHdpdGggTXV0YXRpb25PYnNlcnZlclxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGNsaWNrcyBvbiB0aGUgZmFrZSAuYmFja2Ryb3AgZWxlbWVudCwgcmVkaXJlY3RpbmcgdGhlbSBhcyBpZlxuICAgICAqIHRoZXkgd2VyZSBvbiB0aGUgZGlhbG9nIGl0c2VsZi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IUV2ZW50fSBlIHRvIHJlZGlyZWN0XG4gICAgICovXG4gICAgYmFja2Ryb3BDbGlja186IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICghdGhpcy5kaWFsb2dfLmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSkge1xuICAgICAgICAvLyBDbGlja2luZyBvbiB0aGUgYmFja2Ryb3Agc2hvdWxkIG1vdmUgdGhlIGltcGxpY2l0IGN1cnNvciwgZXZlbiBpZiBkaWFsb2cgY2Fubm90IGJlXG4gICAgICAgIC8vIGZvY3VzZWQuIENyZWF0ZSBhIGZha2UgdGhpbmcgdG8gZm9jdXMgb24uIElmIHRoZSBiYWNrZHJvcCB3YXMgX2JlZm9yZV8gdGhlIGRpYWxvZywgdGhpc1xuICAgICAgICAvLyB3b3VsZCBub3QgYmUgbmVlZGVkIC0gY2xpY2tzIHdvdWxkIG1vdmUgdGhlIGltcGxpY2l0IGN1cnNvciB0aGVyZS5cbiAgICAgICAgdmFyIGZha2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5kaWFsb2dfLmluc2VydEJlZm9yZShmYWtlLCB0aGlzLmRpYWxvZ18uZmlyc3RDaGlsZCk7XG4gICAgICAgIGZha2UudGFiSW5kZXggPSAtMTtcbiAgICAgICAgZmFrZS5mb2N1cygpO1xuICAgICAgICB0aGlzLmRpYWxvZ18ucmVtb3ZlQ2hpbGQoZmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRpYWxvZ18uZm9jdXMoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZGlyZWN0ZWRFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpO1xuICAgICAgcmVkaXJlY3RlZEV2ZW50LmluaXRNb3VzZUV2ZW50KGUudHlwZSwgZS5idWJibGVzLCBlLmNhbmNlbGFibGUsIHdpbmRvdyxcbiAgICAgICAgICBlLmRldGFpbCwgZS5zY3JlZW5YLCBlLnNjcmVlblksIGUuY2xpZW50WCwgZS5jbGllbnRZLCBlLmN0cmxLZXksXG4gICAgICAgICAgZS5hbHRLZXksIGUuc2hpZnRLZXksIGUubWV0YUtleSwgZS5idXR0b24sIGUucmVsYXRlZFRhcmdldCk7XG4gICAgICB0aGlzLmRpYWxvZ18uZGlzcGF0Y2hFdmVudChyZWRpcmVjdGVkRXZlbnQpO1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRm9jdXNlcyBvbiB0aGUgZmlyc3QgZm9jdXNhYmxlIGVsZW1lbnQgd2l0aGluIHRoZSBkaWFsb2cuIFRoaXMgd2lsbCBhbHdheXMgYmx1ciB0aGUgY3VycmVudFxuICAgICAqIGZvY3VzLCBldmVuIGlmIG5vdGhpbmcgd2l0aGluIHRoZSBkaWFsb2cgaXMgZm91bmQuXG4gICAgICovXG4gICAgZm9jdXNfOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIEZpbmQgZWxlbWVudCB3aXRoIGBhdXRvZm9jdXNgIGF0dHJpYnV0ZSwgb3IgZmFsbCBiYWNrIHRvIHRoZSBmaXJzdCBmb3JtL3RhYmluZGV4IGNvbnRyb2wuXG4gICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5kaWFsb2dfLnF1ZXJ5U2VsZWN0b3IoJ1thdXRvZm9jdXNdOm5vdChbZGlzYWJsZWRdKScpO1xuICAgICAgaWYgKCF0YXJnZXQgJiYgdGhpcy5kaWFsb2dfLnRhYkluZGV4ID49IDApIHtcbiAgICAgICAgdGFyZ2V0ID0gdGhpcy5kaWFsb2dfO1xuICAgICAgfVxuICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgaXMgJ2FueSBmb2N1c2FibGUgYXJlYScuIFRoaXMgbGlzdCBpcyBwcm9iYWJseSBub3QgZXhoYXVzdGl2ZSwgYnV0IHRoZVxuICAgICAgICAvLyBhbHRlcm5hdGl2ZSBpbnZvbHZlcyBzdGVwcGluZyB0aHJvdWdoIGFuZCB0cnlpbmcgdG8gZm9jdXMgZXZlcnl0aGluZy5cbiAgICAgICAgdmFyIG9wdHMgPSBbJ2J1dHRvbicsICdpbnB1dCcsICdrZXlnZW4nLCAnc2VsZWN0JywgJ3RleHRhcmVhJ107XG4gICAgICAgIHZhciBxdWVyeSA9IG9wdHMubWFwKGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgcmV0dXJuIGVsICsgJzpub3QoW2Rpc2FibGVkXSknO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gVE9ETyhzYW10aG9yKTogdGFiaW5kZXggdmFsdWVzIHRoYXQgYXJlIG5vdCBudW1lcmljIGFyZSBub3QgZm9jdXNhYmxlLlxuICAgICAgICBxdWVyeS5wdXNoKCdbdGFiaW5kZXhdOm5vdChbZGlzYWJsZWRdKTpub3QoW3RhYmluZGV4PVwiXCJdKScpOyAgLy8gdGFiaW5kZXggIT0gXCJcIiwgbm90IGRpc2FibGVkXG4gICAgICAgIHRhcmdldCA9IHRoaXMuZGlhbG9nXy5xdWVyeVNlbGVjdG9yKHF1ZXJ5LmpvaW4oJywgJykpO1xuICAgICAgfVxuICAgICAgc2FmZUJsdXIoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCk7XG4gICAgICB0YXJnZXQgJiYgdGFyZ2V0LmZvY3VzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHpJbmRleCBmb3IgdGhlIGJhY2tkcm9wIGFuZCBkaWFsb2cuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGlhbG9nWlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiYWNrZHJvcFpcbiAgICAgKi9cbiAgICB1cGRhdGVaSW5kZXg6IGZ1bmN0aW9uKGRpYWxvZ1osIGJhY2tkcm9wWikge1xuICAgICAgaWYgKGRpYWxvZ1ogPCBiYWNrZHJvcFopIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWFsb2daIHNob3VsZCBuZXZlciBiZSA8IGJhY2tkcm9wWicpO1xuICAgICAgfVxuICAgICAgdGhpcy5kaWFsb2dfLnN0eWxlLnpJbmRleCA9IGRpYWxvZ1o7XG4gICAgICB0aGlzLmJhY2tkcm9wXy5zdHlsZS56SW5kZXggPSBiYWNrZHJvcFo7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNob3dzIHRoZSBkaWFsb2cuIElmIHRoZSBkaWFsb2cgaXMgYWxyZWFkeSBvcGVuLCB0aGlzIGRvZXMgbm90aGluZy5cbiAgICAgKi9cbiAgICBzaG93OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5kaWFsb2dfLm9wZW4pIHtcbiAgICAgICAgdGhpcy5zZXRPcGVuKHRydWUpO1xuICAgICAgICB0aGlzLmZvY3VzXygpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTaG93IHRoaXMgZGlhbG9nIG1vZGFsbHkuXG4gICAgICovXG4gICAgc2hvd01vZGFsOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmRpYWxvZ18uaGFzQXR0cmlidXRlKCdvcGVuJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZXhlY3V0ZSBcXCdzaG93TW9kYWxcXCcgb24gZGlhbG9nOiBUaGUgZWxlbWVudCBpcyBhbHJlYWR5IG9wZW4sIGFuZCB0aGVyZWZvcmUgY2Fubm90IGJlIG9wZW5lZCBtb2RhbGx5LicpO1xuICAgICAgfVxuICAgICAgaWYgKCFkb2N1bWVudC5ib2R5LmNvbnRhaW5zKHRoaXMuZGlhbG9nXykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZXhlY3V0ZSBcXCdzaG93TW9kYWxcXCcgb24gZGlhbG9nOiBUaGUgZWxlbWVudCBpcyBub3QgaW4gYSBEb2N1bWVudC4nKTtcbiAgICAgIH1cbiAgICAgIGlmICghZGlhbG9nUG9seWZpbGwuZG0ucHVzaERpYWxvZyh0aGlzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBleGVjdXRlIFxcJ3Nob3dNb2RhbFxcJyBvbiBkaWFsb2c6IFRoZXJlIGFyZSB0b28gbWFueSBvcGVuIG1vZGFsIGRpYWxvZ3MuJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjcmVhdGVzU3RhY2tpbmdDb250ZXh0KHRoaXMuZGlhbG9nXy5wYXJlbnRFbGVtZW50KSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0EgZGlhbG9nIGlzIGJlaW5nIHNob3duIGluc2lkZSBhIHN0YWNraW5nIGNvbnRleHQuICcgK1xuICAgICAgICAgICAgJ1RoaXMgbWF5IGNhdXNlIGl0IHRvIGJlIHVudXNhYmxlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlIHRoaXMgbGluazogJyArXG4gICAgICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZS9kaWFsb2ctcG9seWZpbGwvI3N0YWNraW5nLWNvbnRleHQnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRPcGVuKHRydWUpO1xuICAgICAgdGhpcy5vcGVuQXNNb2RhbF8gPSB0cnVlO1xuXG4gICAgICAvLyBPcHRpb25hbGx5IGNlbnRlciB2ZXJ0aWNhbGx5LCByZWxhdGl2ZSB0byB0aGUgY3VycmVudCB2aWV3cG9ydC5cbiAgICAgIGlmIChkaWFsb2dQb2x5ZmlsbC5uZWVkc0NlbnRlcmluZyh0aGlzLmRpYWxvZ18pKSB7XG4gICAgICAgIGRpYWxvZ1BvbHlmaWxsLnJlcG9zaXRpb24odGhpcy5kaWFsb2dfKTtcbiAgICAgICAgdGhpcy5yZXBsYWNlZFN0eWxlVG9wXyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlcGxhY2VkU3R5bGVUb3BfID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIEluc2VydCBiYWNrZHJvcC5cbiAgICAgIHRoaXMuZGlhbG9nXy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmJhY2tkcm9wXywgdGhpcy5kaWFsb2dfLm5leHRTaWJsaW5nKTtcblxuICAgICAgLy8gRm9jdXMgb24gd2hhdGV2ZXIgaW5zaWRlIHRoZSBkaWFsb2cuXG4gICAgICB0aGlzLmZvY3VzXygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhpcyBIVE1MRGlhbG9nRWxlbWVudC4gVGhpcyBpcyBvcHRpb25hbCB2cyBjbGVhcmluZyB0aGUgb3BlblxuICAgICAqIGF0dHJpYnV0ZSwgaG93ZXZlciB0aGlzIGZpcmVzIGEgJ2Nsb3NlJyBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3JldHVyblZhbHVlIHRvIHVzZSBhcyB0aGUgcmV0dXJuVmFsdWVcbiAgICAgKi9cbiAgICBjbG9zZTogZnVuY3Rpb24ob3B0X3JldHVyblZhbHVlKSB7XG4gICAgICBpZiAoIXRoaXMuZGlhbG9nXy5oYXNBdHRyaWJ1dGUoJ29wZW4nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBleGVjdXRlIFxcJ2Nsb3NlXFwnIG9uIGRpYWxvZzogVGhlIGVsZW1lbnQgZG9lcyBub3QgaGF2ZSBhbiBcXCdvcGVuXFwnIGF0dHJpYnV0ZSwgYW5kIHRoZXJlZm9yZSBjYW5ub3QgYmUgY2xvc2VkLicpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRPcGVuKGZhbHNlKTtcblxuICAgICAgLy8gTGVhdmUgcmV0dXJuVmFsdWUgdW50b3VjaGVkIGluIGNhc2UgaXQgd2FzIHNldCBkaXJlY3RseSBvbiB0aGUgZWxlbWVudFxuICAgICAgaWYgKG9wdF9yZXR1cm5WYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZGlhbG9nXy5yZXR1cm5WYWx1ZSA9IG9wdF9yZXR1cm5WYWx1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gVHJpZ2dlcmluZyBcImNsb3NlXCIgZXZlbnQgZm9yIGFueSBhdHRhY2hlZCBsaXN0ZW5lcnMgb24gdGhlIDxkaWFsb2c+LlxuICAgICAgdmFyIGNsb3NlRXZlbnQgPSBuZXcgc3VwcG9ydEN1c3RvbUV2ZW50KCdjbG9zZScsIHtcbiAgICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZGlhbG9nXy5kaXNwYXRjaEV2ZW50KGNsb3NlRXZlbnQpO1xuICAgIH1cblxuICB9O1xuXG4gIHZhciBkaWFsb2dQb2x5ZmlsbCA9IHt9O1xuXG4gIGRpYWxvZ1BvbHlmaWxsLnJlcG9zaXRpb24gPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgdmFyIHNjcm9sbFRvcCA9IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3A7XG4gICAgdmFyIHRvcFZhbHVlID0gc2Nyb2xsVG9wICsgKHdpbmRvdy5pbm5lckhlaWdodCAtIGVsZW1lbnQub2Zmc2V0SGVpZ2h0KSAvIDI7XG4gICAgZWxlbWVudC5zdHlsZS50b3AgPSBNYXRoLm1heChzY3JvbGxUb3AsIHRvcFZhbHVlKSArICdweCc7XG4gIH07XG5cbiAgZGlhbG9nUG9seWZpbGwuaXNJbmxpbmVQb3NpdGlvblNldEJ5U3R5bGVzaGVldCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvY3VtZW50LnN0eWxlU2hlZXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgc3R5bGVTaGVldCA9IGRvY3VtZW50LnN0eWxlU2hlZXRzW2ldO1xuICAgICAgdmFyIGNzc1J1bGVzID0gbnVsbDtcbiAgICAgIC8vIFNvbWUgYnJvd3NlcnMgdGhyb3cgb24gY3NzUnVsZXMuXG4gICAgICB0cnkge1xuICAgICAgICBjc3NSdWxlcyA9IHN0eWxlU2hlZXQuY3NzUnVsZXM7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgaWYgKCFjc3NSdWxlcykgeyBjb250aW51ZTsgfVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjc3NSdWxlcy5sZW5ndGg7ICsraikge1xuICAgICAgICB2YXIgcnVsZSA9IGNzc1J1bGVzW2pdO1xuICAgICAgICB2YXIgc2VsZWN0ZWROb2RlcyA9IG51bGw7XG4gICAgICAgIC8vIElnbm9yZSBlcnJvcnMgb24gaW52YWxpZCBzZWxlY3RvciB0ZXh0cy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzZWxlY3RlZE5vZGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChydWxlLnNlbGVjdG9yVGV4dCk7XG4gICAgICAgIH0gY2F0Y2goZSkge31cbiAgICAgICAgaWYgKCFzZWxlY3RlZE5vZGVzIHx8ICFpbk5vZGVMaXN0KHNlbGVjdGVkTm9kZXMsIGVsZW1lbnQpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNzc1RvcCA9IHJ1bGUuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgndG9wJyk7XG4gICAgICAgIHZhciBjc3NCb3R0b20gPSBydWxlLnN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ2JvdHRvbScpO1xuICAgICAgICBpZiAoKGNzc1RvcCAmJiBjc3NUb3AgIT09ICdhdXRvJykgfHwgKGNzc0JvdHRvbSAmJiBjc3NCb3R0b20gIT09ICdhdXRvJykpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgZGlhbG9nUG9seWZpbGwubmVlZHNDZW50ZXJpbmcgPSBmdW5jdGlvbihkaWFsb2cpIHtcbiAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRpYWxvZyk7XG4gICAgaWYgKGNvbXB1dGVkU3R5bGUucG9zaXRpb24gIT09ICdhYnNvbHV0ZScpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBXZSBtdXN0IGRldGVybWluZSB3aGV0aGVyIHRoZSB0b3AvYm90dG9tIHNwZWNpZmllZCB2YWx1ZSBpcyBub24tYXV0by4gIEluXG4gICAgLy8gV2ViS2l0L0JsaW5rLCBjaGVja2luZyBjb21wdXRlZFN0eWxlLnRvcCA9PSAnYXV0bycgaXMgc3VmZmljaWVudCwgYnV0XG4gICAgLy8gRmlyZWZveCByZXR1cm5zIHRoZSB1c2VkIHZhbHVlLiBTbyB3ZSBkbyB0aGlzIGNyYXp5IHRoaW5nIGluc3RlYWQ6IGNoZWNrXG4gICAgLy8gdGhlIGlubGluZSBzdHlsZSBhbmQgdGhlbiBnbyB0aHJvdWdoIENTUyBydWxlcy5cbiAgICBpZiAoKGRpYWxvZy5zdHlsZS50b3AgIT09ICdhdXRvJyAmJiBkaWFsb2cuc3R5bGUudG9wICE9PSAnJykgfHxcbiAgICAgICAgKGRpYWxvZy5zdHlsZS5ib3R0b20gIT09ICdhdXRvJyAmJiBkaWFsb2cuc3R5bGUuYm90dG9tICE9PSAnJykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuICFkaWFsb2dQb2x5ZmlsbC5pc0lubGluZVBvc2l0aW9uU2V0QnlTdHlsZXNoZWV0KGRpYWxvZyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnQgdG8gZm9yY2UgdXBncmFkZVxuICAgKi9cbiAgZGlhbG9nUG9seWZpbGwuZm9yY2VSZWdpc3RlckRpYWxvZyA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBpZiAod2luZG93LkhUTUxEaWFsb2dFbGVtZW50IHx8IGVsZW1lbnQuc2hvd01vZGFsKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1RoaXMgYnJvd3NlciBhbHJlYWR5IHN1cHBvcnRzIDxkaWFsb2c+LCB0aGUgcG9seWZpbGwgJyArXG4gICAgICAgICAgJ21heSBub3Qgd29yayBjb3JyZWN0bHknLCBlbGVtZW50KTtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQubG9jYWxOYW1lICE9PSAnZGlhbG9nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcmVnaXN0ZXIgZGlhbG9nOiBUaGUgZWxlbWVudCBpcyBub3QgYSBkaWFsb2cuJyk7XG4gICAgfVxuICAgIG5ldyBkaWFsb2dQb2x5ZmlsbEluZm8oLyoqIEB0eXBlIHshSFRNTERpYWxvZ0VsZW1lbnR9ICovIChlbGVtZW50KSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnQgdG8gdXBncmFkZSwgaWYgbmVjZXNzYXJ5XG4gICAqL1xuICBkaWFsb2dQb2x5ZmlsbC5yZWdpc3RlckRpYWxvZyA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBpZiAoIWVsZW1lbnQuc2hvd01vZGFsKSB7XG4gICAgICBkaWFsb2dQb2x5ZmlsbC5mb3JjZVJlZ2lzdGVyRGlhbG9nKGVsZW1lbnQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBkaWFsb2dQb2x5ZmlsbC5EaWFsb2dNYW5hZ2VyID0gZnVuY3Rpb24oKSB7XG4gICAgLyoqIEB0eXBlIHshQXJyYXk8IWRpYWxvZ1BvbHlmaWxsSW5mbz59ICovXG4gICAgdGhpcy5wZW5kaW5nRGlhbG9nU3RhY2sgPSBbXTtcblxuICAgIHZhciBjaGVja0RPTSA9IHRoaXMuY2hlY2tET01fLmJpbmQodGhpcyk7XG5cbiAgICAvLyBUaGUgb3ZlcmxheSBpcyB1c2VkIHRvIHNpbXVsYXRlIGhvdyBhIG1vZGFsIGRpYWxvZyBibG9ja3MgdGhlIGRvY3VtZW50LlxuICAgIC8vIFRoZSBibG9ja2luZyBkaWFsb2cgaXMgcG9zaXRpb25lZCBvbiB0b3Agb2YgdGhlIG92ZXJsYXksIGFuZCB0aGUgcmVzdCBvZlxuICAgIC8vIHRoZSBkaWFsb2dzIG9uIHRoZSBwZW5kaW5nIGRpYWxvZyBzdGFjayBhcmUgcG9zaXRpb25lZCBiZWxvdyBpdC4gSW4gdGhlXG4gICAgLy8gYWN0dWFsIGltcGxlbWVudGF0aW9uLCB0aGUgbW9kYWwgZGlhbG9nIHN0YWNraW5nIGlzIGNvbnRyb2xsZWQgYnkgdGhlXG4gICAgLy8gdG9wIGxheWVyLCB3aGVyZSB6LWluZGV4IGhhcyBubyBlZmZlY3QuXG4gICAgdGhpcy5vdmVybGF5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5vdmVybGF5LmNsYXNzTmFtZSA9ICdfZGlhbG9nX292ZXJsYXknO1xuICAgIHRoaXMub3ZlcmxheS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHRoaXMuZm9yd2FyZFRhYl8gPSB1bmRlZmluZWQ7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgY2hlY2tET00oW10pOyAgLy8gc2FuaXR5LWNoZWNrIERPTVxuICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICB0aGlzLmhhbmRsZUtleV8gPSB0aGlzLmhhbmRsZUtleV8uYmluZCh0aGlzKTtcbiAgICB0aGlzLmhhbmRsZUZvY3VzXyA9IHRoaXMuaGFuZGxlRm9jdXNfLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLnpJbmRleExvd18gPSAxMDAwMDA7XG4gICAgdGhpcy56SW5kZXhIaWdoXyA9IDEwMDAwMCArIDE1MDtcblxuICAgIHRoaXMuZm9yd2FyZFRhYl8gPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoJ011dGF0aW9uT2JzZXJ2ZXInIGluIHdpbmRvdykge1xuICAgICAgdGhpcy5tb18gPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbihyZWNvcmRzKSB7XG4gICAgICAgIHZhciByZW1vdmVkID0gW107XG4gICAgICAgIHJlY29yZHMuZm9yRWFjaChmdW5jdGlvbihyZWMpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgYzsgYyA9IHJlYy5yZW1vdmVkTm9kZXNbaV07ICsraSkge1xuICAgICAgICAgICAgaWYgKCEoYyBpbnN0YW5jZW9mIEVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjLmxvY2FsTmFtZSA9PT0gJ2RpYWxvZycpIHtcbiAgICAgICAgICAgICAgcmVtb3ZlZC5wdXNoKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVtb3ZlZCA9IHJlbW92ZWQuY29uY2F0KGMucXVlcnlTZWxlY3RvckFsbCgnZGlhbG9nJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJlbW92ZWQubGVuZ3RoICYmIGNoZWNrRE9NKHJlbW92ZWQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgb24gdGhlIGZpcnN0IG1vZGFsIGRpYWxvZyBiZWluZyBzaG93bi4gQWRkcyB0aGUgb3ZlcmxheSBhbmQgcmVsYXRlZFxuICAgKiBoYW5kbGVycy5cbiAgICovXG4gIGRpYWxvZ1BvbHlmaWxsLkRpYWxvZ01hbmFnZXIucHJvdG90eXBlLmJsb2NrRG9jdW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLmhhbmRsZUZvY3VzXywgdHJ1ZSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5Xyk7XG4gICAgdGhpcy5tb18gJiYgdGhpcy5tb18ub2JzZXJ2ZShkb2N1bWVudCwge2NoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZX0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgb24gdGhlIGZpcnN0IG1vZGFsIGRpYWxvZyBiZWluZyByZW1vdmVkLCBpLmUuLCB3aGVuIG5vIG1vcmUgbW9kYWxcbiAgICogZGlhbG9ncyBhcmUgdmlzaWJsZS5cbiAgICovXG4gIGRpYWxvZ1BvbHlmaWxsLkRpYWxvZ01hbmFnZXIucHJvdG90eXBlLnVuYmxvY2tEb2N1bWVudCA9IGZ1bmN0aW9uKCkge1xuICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuaGFuZGxlRm9jdXNfLCB0cnVlKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlfKTtcbiAgICB0aGlzLm1vXyAmJiB0aGlzLm1vXy5kaXNjb25uZWN0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHN0YWNraW5nIG9mIGFsbCBrbm93biBkaWFsb2dzLlxuICAgKi9cbiAgZGlhbG9nUG9seWZpbGwuRGlhbG9nTWFuYWdlci5wcm90b3R5cGUudXBkYXRlU3RhY2tpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgekluZGV4ID0gdGhpcy56SW5kZXhIaWdoXztcblxuICAgIGZvciAodmFyIGkgPSAwLCBkcGk7IGRwaSA9IHRoaXMucGVuZGluZ0RpYWxvZ1N0YWNrW2ldOyArK2kpIHtcbiAgICAgIGRwaS51cGRhdGVaSW5kZXgoLS16SW5kZXgsIC0tekluZGV4KTtcbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIHRoaXMub3ZlcmxheS5zdHlsZS56SW5kZXggPSAtLXpJbmRleDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNYWtlIHRoZSBvdmVybGF5IGEgc2libGluZyBvZiB0aGUgZGlhbG9nIGl0c2VsZi5cbiAgICB2YXIgbGFzdCA9IHRoaXMucGVuZGluZ0RpYWxvZ1N0YWNrWzBdO1xuICAgIGlmIChsYXN0KSB7XG4gICAgICB2YXIgcCA9IGxhc3QuZGlhbG9nLnBhcmVudE5vZGUgfHwgZG9jdW1lbnQuYm9keTtcbiAgICAgIHAuYXBwZW5kQ2hpbGQodGhpcy5vdmVybGF5KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMub3ZlcmxheS5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLm92ZXJsYXkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLm92ZXJsYXkpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBjYW5kaWRhdGUgdG8gY2hlY2sgaWYgY29udGFpbmVkIG9yIGlzIHRoZSB0b3AtbW9zdCBtb2RhbCBkaWFsb2dcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gd2hldGhlciBjYW5kaWRhdGUgaXMgY29udGFpbmVkIGluIHRvcCBkaWFsb2dcbiAgICovXG4gIGRpYWxvZ1BvbHlmaWxsLkRpYWxvZ01hbmFnZXIucHJvdG90eXBlLmNvbnRhaW5lZEJ5VG9wRGlhbG9nXyA9IGZ1bmN0aW9uKGNhbmRpZGF0ZSkge1xuICAgIHdoaWxlIChjYW5kaWRhdGUgPSBmaW5kTmVhcmVzdERpYWxvZyhjYW5kaWRhdGUpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgZHBpOyBkcGkgPSB0aGlzLnBlbmRpbmdEaWFsb2dTdGFja1tpXTsgKytpKSB7XG4gICAgICAgIGlmIChkcGkuZGlhbG9nID09PSBjYW5kaWRhdGUpIHtcbiAgICAgICAgICByZXR1cm4gaSA9PT0gMDsgIC8vIG9ubHkgdmFsaWQgaWYgdG9wLW1vc3RcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2FuZGlkYXRlID0gY2FuZGlkYXRlLnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBkaWFsb2dQb2x5ZmlsbC5EaWFsb2dNYW5hZ2VyLnByb3RvdHlwZS5oYW5kbGVGb2N1c18gPSBmdW5jdGlvbihldmVudCkge1xuICAgIGlmICh0aGlzLmNvbnRhaW5lZEJ5VG9wRGlhbG9nXyhldmVudC50YXJnZXQpKSB7IHJldHVybjsgfVxuXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBzYWZlQmx1cigvKiogQHR5cGUge0VsZW1lbnR9ICovIChldmVudC50YXJnZXQpKTtcblxuICAgIGlmICh0aGlzLmZvcndhcmRUYWJfID09PSB1bmRlZmluZWQpIHsgcmV0dXJuOyB9ICAvLyBtb3ZlIGZvY3VzIG9ubHkgZnJvbSBhIHRhYiBrZXlcblxuICAgIHZhciBkcGkgPSB0aGlzLnBlbmRpbmdEaWFsb2dTdGFja1swXTtcbiAgICB2YXIgZGlhbG9nID0gZHBpLmRpYWxvZztcbiAgICB2YXIgcG9zaXRpb24gPSBkaWFsb2cuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZXZlbnQudGFyZ2V0KTtcbiAgICBpZiAocG9zaXRpb24gJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElORykge1xuICAgICAgaWYgKHRoaXMuZm9yd2FyZFRhYl8pIHsgIC8vIGZvcndhcmRcbiAgICAgICAgZHBpLmZvY3VzXygpO1xuICAgICAgfSBlbHNlIHsgIC8vIGJhY2t3YXJkc1xuICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETzogRm9jdXMgYWZ0ZXIgdGhlIGRpYWxvZywgaXMgaWdub3JlZC5cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgZGlhbG9nUG9seWZpbGwuRGlhbG9nTWFuYWdlci5wcm90b3R5cGUuaGFuZGxlS2V5XyA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdGhpcy5mb3J3YXJkVGFiXyA9IHVuZGVmaW5lZDtcbiAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMjcpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIHZhciBjYW5jZWxFdmVudCA9IG5ldyBzdXBwb3J0Q3VzdG9tRXZlbnQoJ2NhbmNlbCcsIHtcbiAgICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdmFyIGRwaSA9IHRoaXMucGVuZGluZ0RpYWxvZ1N0YWNrWzBdO1xuICAgICAgaWYgKGRwaSAmJiBkcGkuZGlhbG9nLmRpc3BhdGNoRXZlbnQoY2FuY2VsRXZlbnQpKSB7XG4gICAgICAgIGRwaS5kaWFsb2cuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT09IDkpIHtcbiAgICAgIHRoaXMuZm9yd2FyZFRhYl8gPSAhZXZlbnQuc2hpZnRLZXk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBGaW5kcyBhbmQgZG93bmdyYWRlcyBhbnkga25vd24gbW9kYWwgZGlhbG9ncyB0aGF0IGFyZSBubyBsb25nZXIgZGlzcGxheWVkLiBEaWFsb2dzIHRoYXQgYXJlXG4gICAqIHJlbW92ZWQgYW5kIGltbWVkaWF0ZWx5IHJlYWRkZWQgZG9uJ3Qgc3RheSBtb2RhbCwgdGhleSBiZWNvbWUgbm9ybWFsLlxuICAgKlxuICAgKiBAcGFyYW0geyFBcnJheTwhSFRNTERpYWxvZ0VsZW1lbnQ+fSByZW1vdmVkIHRoYXQgaGF2ZSBkZWZpbml0ZWx5IGJlZW4gcmVtb3ZlZFxuICAgKi9cbiAgZGlhbG9nUG9seWZpbGwuRGlhbG9nTWFuYWdlci5wcm90b3R5cGUuY2hlY2tET01fID0gZnVuY3Rpb24ocmVtb3ZlZCkge1xuICAgIC8vIFRoaXMgb3BlcmF0ZXMgb24gYSBjbG9uZSBiZWNhdXNlIGl0IG1heSBjYXVzZSBpdCB0byBjaGFuZ2UuIEVhY2ggY2hhbmdlIGFsc28gY2FsbHNcbiAgICAvLyB1cGRhdGVTdGFja2luZywgd2hpY2ggb25seSBhY3R1YWxseSBuZWVkcyB0byBoYXBwZW4gb25jZS4gQnV0IHdobyByZW1vdmVzIG1hbnkgbW9kYWwgZGlhbG9nc1xuICAgIC8vIGF0IGEgdGltZT8hXG4gICAgdmFyIGNsb25lID0gdGhpcy5wZW5kaW5nRGlhbG9nU3RhY2suc2xpY2UoKTtcbiAgICBjbG9uZS5mb3JFYWNoKGZ1bmN0aW9uKGRwaSkge1xuICAgICAgaWYgKHJlbW92ZWQuaW5kZXhPZihkcGkuZGlhbG9nKSAhPT0gLTEpIHtcbiAgICAgICAgZHBpLmRvd25ncmFkZU1vZGFsKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkcGkubWF5YmVIaWRlTW9kYWwoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHshZGlhbG9nUG9seWZpbGxJbmZvfSBkcGlcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gd2hldGhlciB0aGUgZGlhbG9nIHdhcyBhbGxvd2VkXG4gICAqL1xuICBkaWFsb2dQb2x5ZmlsbC5EaWFsb2dNYW5hZ2VyLnByb3RvdHlwZS5wdXNoRGlhbG9nID0gZnVuY3Rpb24oZHBpKSB7XG4gICAgdmFyIGFsbG93ZWQgPSAodGhpcy56SW5kZXhIaWdoXyAtIHRoaXMuekluZGV4TG93XykgLyAyIC0gMTtcbiAgICBpZiAodGhpcy5wZW5kaW5nRGlhbG9nU3RhY2subGVuZ3RoID49IGFsbG93ZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMucGVuZGluZ0RpYWxvZ1N0YWNrLnVuc2hpZnQoZHBpKSA9PT0gMSkge1xuICAgICAgdGhpcy5ibG9ja0RvY3VtZW50KCk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlU3RhY2tpbmcoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHshZGlhbG9nUG9seWZpbGxJbmZvfSBkcGlcbiAgICovXG4gIGRpYWxvZ1BvbHlmaWxsLkRpYWxvZ01hbmFnZXIucHJvdG90eXBlLnJlbW92ZURpYWxvZyA9IGZ1bmN0aW9uKGRwaSkge1xuICAgIHZhciBpbmRleCA9IHRoaXMucGVuZGluZ0RpYWxvZ1N0YWNrLmluZGV4T2YoZHBpKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7IHJldHVybjsgfVxuXG4gICAgdGhpcy5wZW5kaW5nRGlhbG9nU3RhY2suc3BsaWNlKGluZGV4LCAxKTtcbiAgICBpZiAodGhpcy5wZW5kaW5nRGlhbG9nU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLnVuYmxvY2tEb2N1bWVudCgpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVN0YWNraW5nKCk7XG4gIH07XG5cbiAgZGlhbG9nUG9seWZpbGwuZG0gPSBuZXcgZGlhbG9nUG9seWZpbGwuRGlhbG9nTWFuYWdlcigpO1xuICBkaWFsb2dQb2x5ZmlsbC5mb3JtU3VibWl0dGVyID0gbnVsbDtcbiAgZGlhbG9nUG9seWZpbGwudXNlVmFsdWUgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBJbnN0YWxscyBnbG9iYWwgaGFuZGxlcnMsIHN1Y2ggYXMgY2xpY2sgbGlzdGVycyBhbmQgbmF0aXZlIG1ldGhvZCBvdmVycmlkZXMuIFRoZXNlIGFyZSBuZWVkZWRcbiAgICogZXZlbiBpZiBhIG5vIGRpYWxvZyBpcyByZWdpc3RlcmVkLCBhcyB0aGV5IGRlYWwgd2l0aCA8Zm9ybSBtZXRob2Q9XCJkaWFsb2dcIj4uXG4gICAqL1xuICBpZiAod2luZG93LkhUTUxEaWFsb2dFbGVtZW50ID09PSB1bmRlZmluZWQpIHtcblxuICAgIC8qKlxuICAgICAqIElmIEhUTUxGb3JtRWxlbWVudCB0cmFuc2xhdGVzIG1ldGhvZD1cIkRJQUxPR1wiIGludG8gJ2dldCcsIHRoZW4gcmVwbGFjZSB0aGUgZGVzY3JpcHRvciB3aXRoXG4gICAgICogb25lIHRoYXQgcmV0dXJucyB0aGUgY29ycmVjdCB2YWx1ZS5cbiAgICAgKi9cbiAgICB2YXIgdGVzdEZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJyk7XG4gICAgdGVzdEZvcm0uc2V0QXR0cmlidXRlKCdtZXRob2QnLCAnZGlhbG9nJyk7XG4gICAgaWYgKHRlc3RGb3JtLm1ldGhvZCAhPT0gJ2RpYWxvZycpIHtcbiAgICAgIHZhciBtZXRob2REZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihIVE1MRm9ybUVsZW1lbnQucHJvdG90eXBlLCAnbWV0aG9kJyk7XG4gICAgICBpZiAobWV0aG9kRGVzY3JpcHRvcikge1xuICAgICAgICAvLyBuYi4gU29tZSBvbGRlciBpT1MgYW5kIG9sZGVyIFBoYW50b21KUyBmYWlsIHRvIHJldHVybiB0aGUgZGVzY3JpcHRvci4gRG9uJ3QgZG8gYW55dGhpbmdcbiAgICAgICAgLy8gYW5kIGRvbid0IGJvdGhlciB0byB1cGRhdGUgdGhlIGVsZW1lbnQuXG4gICAgICAgIHZhciByZWFsR2V0ID0gbWV0aG9kRGVzY3JpcHRvci5nZXQ7XG4gICAgICAgIG1ldGhvZERlc2NyaXB0b3IuZ2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKGlzRm9ybU1ldGhvZERpYWxvZyh0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuICdkaWFsb2cnO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVhbEdldC5jYWxsKHRoaXMpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVhbFNldCA9IG1ldGhvZERlc2NyaXB0b3Iuc2V0O1xuICAgICAgICBtZXRob2REZXNjcmlwdG9yLnNldCA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnICYmIHYudG9Mb3dlckNhc2UoKSA9PT0gJ2RpYWxvZycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldEF0dHJpYnV0ZSgnbWV0aG9kJywgdik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZWFsU2V0LmNhbGwodGhpcywgdik7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIVE1MRm9ybUVsZW1lbnQucHJvdG90eXBlLCAnbWV0aG9kJywgbWV0aG9kRGVzY3JpcHRvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2xvYmFsICdjbGljaycgaGFuZGxlciwgdG8gY2FwdHVyZSB0aGUgPGlucHV0IHR5cGU9XCJzdWJtaXRcIj4gb3IgPGJ1dHRvbj4gZWxlbWVudCB3aGljaCBoYXNcbiAgICAgKiBzdWJtaXR0ZWQgYSA8Zm9ybSBtZXRob2Q9XCJkaWFsb2dcIj4uIE5lZWRlZCBhcyBTYWZhcmkgYW5kIG90aGVycyBkb24ndCByZXBvcnQgdGhpcyBpbnNpZGVcbiAgICAgKiBkb2N1bWVudC5hY3RpdmVFbGVtZW50LlxuICAgICAqL1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgIGRpYWxvZ1BvbHlmaWxsLmZvcm1TdWJtaXR0ZXIgPSBudWxsO1xuICAgICAgZGlhbG9nUG9seWZpbGwudXNlVmFsdWUgPSBudWxsO1xuICAgICAgaWYgKGV2LmRlZmF1bHRQcmV2ZW50ZWQpIHsgcmV0dXJuOyB9ICAvLyBlLmcuIGEgc3VibWl0IHdoaWNoIHByZXZlbnRzIGRlZmF1bHQgc3VibWlzc2lvblxuXG4gICAgICB2YXIgdGFyZ2V0ID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAoZXYudGFyZ2V0KTtcbiAgICAgIGlmICghdGFyZ2V0IHx8ICFpc0Zvcm1NZXRob2REaWFsb2codGFyZ2V0LmZvcm0pKSB7IHJldHVybjsgfVxuXG4gICAgICB2YXIgdmFsaWQgPSAodGFyZ2V0LnR5cGUgPT09ICdzdWJtaXQnICYmIFsnYnV0dG9uJywgJ2lucHV0J10uaW5kZXhPZih0YXJnZXQubG9jYWxOYW1lKSA+IC0xKTtcbiAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgaWYgKCEodGFyZ2V0LmxvY2FsTmFtZSA9PT0gJ2lucHV0JyAmJiB0YXJnZXQudHlwZSA9PT0gJ2ltYWdlJykpIHsgcmV0dXJuOyB9XG4gICAgICAgIC8vIHRoaXMgaXMgYSA8aW5wdXQgdHlwZT1cImltYWdlXCI+LCB3aGljaCBjYW4gc3VibWl0IGZvcm1zXG4gICAgICAgIGRpYWxvZ1BvbHlmaWxsLnVzZVZhbHVlID0gZXYub2Zmc2V0WCArICcsJyArIGV2Lm9mZnNldFk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkaWFsb2cgPSBmaW5kTmVhcmVzdERpYWxvZyh0YXJnZXQpO1xuICAgICAgaWYgKCFkaWFsb2cpIHsgcmV0dXJuOyB9XG5cbiAgICAgIGRpYWxvZ1BvbHlmaWxsLmZvcm1TdWJtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgfSwgZmFsc2UpO1xuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZSB0aGUgbmF0aXZlIEhUTUxGb3JtRWxlbWVudC5zdWJtaXQoKSBtZXRob2QsIGFzIGl0IHdvbid0IGZpcmUgdGhlXG4gICAgICogc3VibWl0IGV2ZW50IGFuZCBnaXZlIHVzIGEgY2hhbmNlIHRvIHJlc3BvbmQuXG4gICAgICovXG4gICAgdmFyIG5hdGl2ZUZvcm1TdWJtaXQgPSBIVE1MRm9ybUVsZW1lbnQucHJvdG90eXBlLnN1Ym1pdDtcbiAgICB2YXIgcmVwbGFjZW1lbnRGb3JtU3VibWl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFpc0Zvcm1NZXRob2REaWFsb2codGhpcykpIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZUZvcm1TdWJtaXQuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHZhciBkaWFsb2cgPSBmaW5kTmVhcmVzdERpYWxvZyh0aGlzKTtcbiAgICAgIGRpYWxvZyAmJiBkaWFsb2cuY2xvc2UoKTtcbiAgICB9O1xuICAgIEhUTUxGb3JtRWxlbWVudC5wcm90b3R5cGUuc3VibWl0ID0gcmVwbGFjZW1lbnRGb3JtU3VibWl0O1xuXG4gICAgLyoqXG4gICAgICogR2xvYmFsIGZvcm0gJ2RpYWxvZycgbWV0aG9kIGhhbmRsZXIuIENsb3NlcyBhIGRpYWxvZyBjb3JyZWN0bHkgb24gc3VibWl0XG4gICAgICogYW5kIHBvc3NpYmx5IHNldHMgaXRzIHJldHVybiB2YWx1ZS5cbiAgICAgKi9cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzdWJtaXQnLCBmdW5jdGlvbihldikge1xuICAgICAgdmFyIGZvcm0gPSAvKiogQHR5cGUge0hUTUxGb3JtRWxlbWVudH0gKi8gKGV2LnRhcmdldCk7XG4gICAgICBpZiAoIWlzRm9ybU1ldGhvZERpYWxvZyhmb3JtKSkgeyByZXR1cm47IH1cbiAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHZhciBkaWFsb2cgPSBmaW5kTmVhcmVzdERpYWxvZyhmb3JtKTtcbiAgICAgIGlmICghZGlhbG9nKSB7IHJldHVybjsgfVxuXG4gICAgICAvLyBGb3JtcyBjYW4gb25seSBiZSBzdWJtaXR0ZWQgdmlhIC5zdWJtaXQoKSBvciBhIGNsaWNrICg/KSwgYnV0IGFueXdheTogc2FuaXR5LWNoZWNrIHRoYXRcbiAgICAgIC8vIHRoZSBzdWJtaXR0ZXIgaXMgY29ycmVjdCBiZWZvcmUgdXNpbmcgaXRzIHZhbHVlIGFzIC5yZXR1cm5WYWx1ZS5cbiAgICAgIHZhciBzID0gZGlhbG9nUG9seWZpbGwuZm9ybVN1Ym1pdHRlcjtcbiAgICAgIGlmIChzICYmIHMuZm9ybSA9PT0gZm9ybSkge1xuICAgICAgICBkaWFsb2cuY2xvc2UoZGlhbG9nUG9seWZpbGwudXNlVmFsdWUgfHwgcy52YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaWFsb2cuY2xvc2UoKTtcbiAgICAgIH1cbiAgICAgIGRpYWxvZ1BvbHlmaWxsLmZvcm1TdWJtaXR0ZXIgPSBudWxsO1xuICAgIH0sIHRydWUpO1xuICB9XG5cbiAgZGlhbG9nUG9seWZpbGxbJ2ZvcmNlUmVnaXN0ZXJEaWFsb2cnXSA9IGRpYWxvZ1BvbHlmaWxsLmZvcmNlUmVnaXN0ZXJEaWFsb2c7XG4gIGRpYWxvZ1BvbHlmaWxsWydyZWdpc3RlckRpYWxvZyddID0gZGlhbG9nUG9seWZpbGwucmVnaXN0ZXJEaWFsb2c7XG5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgJ2FtZCcgaW4gZGVmaW5lKSB7XG4gICAgLy8gQU1EIHN1cHBvcnRcbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBkaWFsb2dQb2x5ZmlsbDsgfSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZVsnZXhwb3J0cyddID09PSAnb2JqZWN0Jykge1xuICAgIC8vIENvbW1vbkpTIHN1cHBvcnRcbiAgICBtb2R1bGVbJ2V4cG9ydHMnXSA9IGRpYWxvZ1BvbHlmaWxsO1xuICB9IGVsc2Uge1xuICAgIC8vIGFsbCBvdGhlcnNcbiAgICB3aW5kb3dbJ2RpYWxvZ1BvbHlmaWxsJ10gPSBkaWFsb2dQb2x5ZmlsbDtcbiAgfVxufSkoKTtcbiJdLCJuYW1lcyI6WyJzdXBwb3J0Q3VzdG9tRXZlbnQiLCJ3aW5kb3ciLCJDdXN0b21FdmVudCIsImV2ZW50IiwieCIsImV2IiwiZG9jdW1lbnQiLCJjcmVhdGVFdmVudCIsImluaXRDdXN0b21FdmVudCIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwiZGV0YWlsIiwicHJvdG90eXBlIiwiRXZlbnQiLCJjcmVhdGVzU3RhY2tpbmdDb250ZXh0IiwiZWwiLCJib2R5IiwicyIsImdldENvbXB1dGVkU3R5bGUiLCJpbnZhbGlkIiwiayIsIm9rIiwidW5kZWZpbmVkIiwib3BhY2l0eSIsInBvc2l0aW9uIiwid2Via2l0T3ZlcmZsb3dTY3JvbGxpbmciLCJwYXJlbnRFbGVtZW50IiwiZmluZE5lYXJlc3REaWFsb2ciLCJsb2NhbE5hbWUiLCJzYWZlQmx1ciIsImJsdXIiLCJpbk5vZGVMaXN0Iiwibm9kZUxpc3QiLCJub2RlIiwiaSIsImxlbmd0aCIsImlzRm9ybU1ldGhvZERpYWxvZyIsImhhc0F0dHJpYnV0ZSIsImdldEF0dHJpYnV0ZSIsInRvTG93ZXJDYXNlIiwiZGlhbG9nUG9seWZpbGxJbmZvIiwiZGlhbG9nIiwiZGlhbG9nXyIsInJlcGxhY2VkU3R5bGVUb3BfIiwib3BlbkFzTW9kYWxfIiwic2V0QXR0cmlidXRlIiwic2hvdyIsImJpbmQiLCJzaG93TW9kYWwiLCJjbG9zZSIsInJldHVyblZhbHVlIiwibW8iLCJNdXRhdGlvbk9ic2VydmVyIiwibWF5YmVIaWRlTW9kYWwiLCJvYnNlcnZlIiwiYXR0cmlidXRlcyIsImF0dHJpYnV0ZUZpbHRlciIsInJlbW92ZWQiLCJjYiIsImRvd25ncmFkZU1vZGFsIiwidGltZW91dCIsImRlbGF5TW9kZWwiLCJ0YXJnZXQiLCJjYW5kIiwidHlwZSIsInN1YnN0ciIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJmb3JFYWNoIiwibmFtZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsInNldCIsInNldE9wZW4iLCJnZXQiLCJiYWNrZHJvcF8iLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwiYmFja2Ryb3BDbGlja18iLCJjb250YWlucyIsInN0eWxlIiwiekluZGV4IiwidG9wIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiZGlhbG9nUG9seWZpbGwiLCJkbSIsInJlbW92ZURpYWxvZyIsInZhbHVlIiwicmVtb3ZlQXR0cmlidXRlIiwiZSIsImZha2UiLCJpbnNlcnRCZWZvcmUiLCJmaXJzdENoaWxkIiwidGFiSW5kZXgiLCJmb2N1cyIsInJlZGlyZWN0ZWRFdmVudCIsImluaXRNb3VzZUV2ZW50Iiwic2NyZWVuWCIsInNjcmVlblkiLCJjbGllbnRYIiwiY2xpZW50WSIsImN0cmxLZXkiLCJhbHRLZXkiLCJzaGlmdEtleSIsIm1ldGFLZXkiLCJidXR0b24iLCJyZWxhdGVkVGFyZ2V0IiwiZGlzcGF0Y2hFdmVudCIsInN0b3BQcm9wYWdhdGlvbiIsImZvY3VzXyIsInF1ZXJ5U2VsZWN0b3IiLCJvcHRzIiwicXVlcnkiLCJtYXAiLCJwdXNoIiwiam9pbiIsImFjdGl2ZUVsZW1lbnQiLCJ1cGRhdGVaSW5kZXgiLCJkaWFsb2daIiwiYmFja2Ryb3BaIiwiRXJyb3IiLCJvcGVuIiwicHVzaERpYWxvZyIsImNvbnNvbGUiLCJ3YXJuIiwibmVlZHNDZW50ZXJpbmciLCJyZXBvc2l0aW9uIiwibmV4dFNpYmxpbmciLCJvcHRfcmV0dXJuVmFsdWUiLCJjbG9zZUV2ZW50IiwiZWxlbWVudCIsInNjcm9sbFRvcCIsImRvY3VtZW50RWxlbWVudCIsInRvcFZhbHVlIiwiaW5uZXJIZWlnaHQiLCJvZmZzZXRIZWlnaHQiLCJNYXRoIiwibWF4IiwiaXNJbmxpbmVQb3NpdGlvblNldEJ5U3R5bGVzaGVldCIsInN0eWxlU2hlZXRzIiwic3R5bGVTaGVldCIsImNzc1J1bGVzIiwiaiIsInJ1bGUiLCJzZWxlY3RlZE5vZGVzIiwicXVlcnlTZWxlY3RvckFsbCIsInNlbGVjdG9yVGV4dCIsImNzc1RvcCIsImdldFByb3BlcnR5VmFsdWUiLCJjc3NCb3R0b20iLCJjb21wdXRlZFN0eWxlIiwiYm90dG9tIiwiZm9yY2VSZWdpc3RlckRpYWxvZyIsIkhUTUxEaWFsb2dFbGVtZW50IiwicmVnaXN0ZXJEaWFsb2ciLCJEaWFsb2dNYW5hZ2VyIiwicGVuZGluZ0RpYWxvZ1N0YWNrIiwiY2hlY2tET00iLCJjaGVja0RPTV8iLCJvdmVybGF5IiwiZm9yd2FyZFRhYl8iLCJoYW5kbGVLZXlfIiwiaGFuZGxlRm9jdXNfIiwiekluZGV4TG93XyIsInpJbmRleEhpZ2hfIiwibW9fIiwicmVjb3JkcyIsInJlYyIsImMiLCJyZW1vdmVkTm9kZXMiLCJFbGVtZW50IiwiY29uY2F0IiwiYmxvY2tEb2N1bWVudCIsImNoaWxkTGlzdCIsInN1YnRyZWUiLCJ1bmJsb2NrRG9jdW1lbnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZGlzY29ubmVjdCIsInVwZGF0ZVN0YWNraW5nIiwiZHBpIiwibGFzdCIsInAiLCJhcHBlbmRDaGlsZCIsImNvbnRhaW5lZEJ5VG9wRGlhbG9nXyIsImNhbmRpZGF0ZSIsInByZXZlbnREZWZhdWx0IiwiY29tcGFyZURvY3VtZW50UG9zaXRpb24iLCJOb2RlIiwiRE9DVU1FTlRfUE9TSVRJT05fUFJFQ0VESU5HIiwia2V5Q29kZSIsImNhbmNlbEV2ZW50IiwiY2xvbmUiLCJzbGljZSIsImluZGV4T2YiLCJhbGxvd2VkIiwidW5zaGlmdCIsImluZGV4Iiwic3BsaWNlIiwiZm9ybVN1Ym1pdHRlciIsInVzZVZhbHVlIiwidGVzdEZvcm0iLCJtZXRob2QiLCJtZXRob2REZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiSFRNTEZvcm1FbGVtZW50IiwicmVhbEdldCIsImNhbGwiLCJyZWFsU2V0IiwidiIsImRlZmF1bHRQcmV2ZW50ZWQiLCJmb3JtIiwidmFsaWQiLCJvZmZzZXRYIiwib2Zmc2V0WSIsIm5hdGl2ZUZvcm1TdWJtaXQiLCJzdWJtaXQiLCJyZXBsYWNlbWVudEZvcm1TdWJtaXQiLCJkZWZpbmUiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/dialog-polyfill/dialog-polyfill.js\n");

/***/ })

};
;